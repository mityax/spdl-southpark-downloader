<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>spdl API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spdl</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import atexit
import json
import logging
import os
import re
import shutil
import subprocess
import sys
import tempfile
import time
import urllib.parse
import urllib.request
from concurrent.futures.thread import ThreadPoolExecutor
from typing import List, Optional, Tuple, Dict, Any

try:
    from lxml import etree
except ImportError:
    try:
        import xml.etree.ElementTree as etree
    except ImportError:
        try:
            import cElementTree as etree
        except ImportError:
            try:
                import elementtree.ElementTree as etree
            except ImportError:
                raise ImportError(&#34;Couldn&#39;t import ElementTree from any known place - please install lxml for python 3&#34;)

log = logging.getLogger(&#39;spdl&#39;)


def set_tempdir(dir: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;
    Set the directory to put temporary files. The files are deleted automatically when the script exits.
    :param dir: The temporary directory root
    &#34;&#34;&#34;
    global tempdir
    tempdir = os.path.join(dir or tempfile.gettempdir(), f&#39;.spdl-{time.time()}&#39;)
    if not os.path.isdir(tempdir):
        os.mkdir(tempdir)
    atexit.register(lambda: shutil.rmtree(tempdir))
    return tempdir


tempdir = set_tempdir()


DOMAIN_REF = {
    &#39;en&#39;: &#34;southpark.cc.com&#34;,  ## en
    &#39;uk&#39;: &#34;southpark.cc.com&#34;,  ## en uk
    &#39;es&#39;: &#34;southpark.cc.com&#34;,  ## es
    &#39;de&#39;: &#34;www.southpark.de&#34;,  ## de
    &#39;se&#39;: &#34;southparkstudios.nu&#34;  ## se
}

DOMAIN_URL = {
    &#39;en&#39;: &#34;southparkstudios.com&#34;,  ## en
    &#39;uk&#39;: &#34;southparkstudios.com&#34;,  ## en uk
    &#39;es&#39;: &#34;southparkstudios.com&#34;,  ## es
    &#39;de&#39;: &#34;southpark.de&#34;,  ## de
    &#39;se&#39;: &#34;southparkstudios.nu&#34;  ## se
}

ALL_SEASONS_URL = {  # TODO: only the german address is currently valid; correct the others
    &#39;en&#39;: &#34;https://southpark.cc.com/all-episodes&#34;,  ## en
    &#39;uk&#39;: &#34;https://southpark.cc.com/all-episodes&#34;,  ## en uk
    &#39;es&#39;: &#34;https://southpark.cc.com/all-episodes&#34;,  ## es
    &#39;de&#39;: &#34;https://www.southpark.de/alle-episoden&#34;,  ## de
    &#39;se&#39;: &#34;https://southparkstudios.nu&#34;  ## se
}


class Stream(object):
    def __init__(self, resolution: str, url: str):
        self.url: str = url
        &#34;&#34;&#34;The url of the stream.&#34;&#34;&#34;
        self.resolution: str = resolution
        &#34;&#34;&#34;The resolution of the stream as a string in the format \&#34;1920x1080\&#34;&#34;&#34;&#34;

    def __str__(self):
        return f&#34;&lt;{type(self).__name__} at {id(self)} resolution={self.resolution} url=\&#34;{self.url}\&#34;&gt;&#34;

    def __repr__(self):
        return str(self)

    def __lt__(self, other):
        return int(self.resolution.split(&#34;x&#34;)[0]) &lt; int(other.resolution.split(&#34;x&#34;)[0])


class Video:
    RTMP_STREAMS = [
        &#34;rtmpe://viacommtvstrmfs.fplive.net:1935/viacommtvstrm&#34;,
        &#34;rtmpe://cp75298.edgefcs.net/ondemand&#34;
    ]

    def __init__(self, streams: List[str], duration: List[int], captions: str):
        self.__streams = streams
        self.duration: List[int] = duration
        &#34;&#34;&#34;The duration of the video&#34;&#34;&#34;
        self.captions: str = captions
        &#34;&#34;&#34;Sub-titles for the video&#34;&#34;&#34;

    def __rtmp_streams(self, index: int = 0) -&gt; str:
        return self.RTMP_STREAMS[index]

    def get_streams(self) -&gt; List[Stream]:
        &#34;&#34;&#34;
        Get a list of streams in different qualities for this Video. The list is sorted by the
        stream quality in descending order, so that you can easily retrieve the highest quality stream
        using the first element.
        &#34;&#34;&#34;
        p = http_get(self.get_play_data()[1])
        streams = []
        curr_res = None
        for line in p.splitlines():
            if line.startswith(b&#34;#EXT-X-STREAM-INF:&#34;):
                curr_res = re.search(rb&#39;RESOLUTION=(\d+x\d+)&#39;, line).group(1)
            elif not line.startswith(b&#34;#&#34;) and line.strip():
                streams.append(Stream(curr_res.decode(&#34;utf-8&#34;), line.decode(&#34;utf-8&#34;)))
        return sorted(streams, reverse=True)

    def get_stream(self, quality: str = &#39;max&#39;) -&gt; Stream:
        &#34;&#34;&#34;
        Returns a single stream for this video.
        :param quality: The desired quality. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39;, or a resolution like &#39;1920x1080&#39; (the closes matching resolution is taken in this case)
        :return: The Stream object
        &#34;&#34;&#34;
        streams = self.get_streams()
        if quality == &#39;max&#39;:
            return streams[0]
        elif quality == &#39;min&#39;:
            return streams[-1]
        elif quality == &#39;medium&#39;:
            return streams[len(streams) // 2]
        elif re.match(r&#34;\d+x\d+$&#34;, quality):
            q = int(quality.split(&#34;x&#34;)[0]) * int(quality.split(&#34;x&#34;)[0])
            streams = sorted(streams,
                             key=lambda s: abs(q - int(s.resolution.split(&#34;x&#34;)[0]) * int(s.resolution.split(&#34;x&#34;)[0])))
            return streams[0]
        else:
            raise ValueError(
                f&#34;Invalid quality string: \&#34;{quality}\&#34;. Use one of &#39;max&#39;, &#39;medium&#39;, &#39;min&#39; or a resolution like &#39;1920x1080&#39;&#34;)

    def get_play_data(self) -&gt; Tuple[str, str]:
        ## High quality is the last stream  (-1)
        vqual = -1
        rtmp = self.__streams[vqual]
        playpath = &#34;&#34;
        if &#34;http&#34; not in rtmp:
            if &#34;viacomccstrm&#34; in self.__streams[vqual]:
                playpath = &#34;mp4:{0}&#34;.format(self.__streams[vqual].split(&#39;viacomccstrm/&#39;)[1])
                rtmp = self.__rtmp_streams()
            elif &#34;cp9950.edgefcs.net&#34; in self.__streams[vqual]:
                playpath = &#34;mp4:{0}&#34;.format(self.__streams[vqual].split(&#39;mtvnorigin/&#39;)[1])
                rtmp = self.__rtmp_streams()
        return playpath, rtmp


class Episode:
    def __init__(self, id: str, title: str, description: str, short_description: str, thumbnail: str, date: float,
                 episode_number: str, season: Optional[str] = None,
                 episode_number_in_season: Optional[str] = None, _lang: str = &#39;en&#39;):
        self.id: str = id
        &#34;&#34;&#34;The south park intern uid of the episode&#34;&#34;&#34;
        self.title: str = title
        &#34;&#34;&#34;The title of the episode&#34;&#34;&#34;
        self.description: str = description
        &#34;&#34;&#34;The description of the episode&#34;&#34;&#34;
        self.short_description: str = short_description
        &#34;&#34;&#34;A short description of the episode&#34;&#34;&#34;
        self.thumbnail: str = thumbnail
        &#34;&#34;&#34;A URL to the thumbnail image of the episode&#34;&#34;&#34;
        self.date: float = date
        &#34;&#34;&#34;The date of the episode as a unix timestamp&#34;&#34;&#34;
        self.episode_number: str = episode_number
        &#34;&#34;&#34;The global episode number, e.g. &#34;1908&#34; or &#34;2001\&#34;&#34;&#34;&#34;
        self.season: str = season
        &#34;&#34;&#34;The number of the season the episode belongs to&#34;&#34;&#34;
        self.episode_number_in_season: str = episode_number_in_season
        &#34;&#34;&#34;The episode number relative to it&#39;s season, e.g. &#34;06\&#34;&#34;&#34;&#34;
        self.lang: str = _lang
        &#34;&#34;&#34;The language of the episode, inherited from the SouthPark constructor&#34;&#34;&#34;

    def get_videos(self) -&gt; List[Video]:
        &#34;&#34;&#34;
        Each south park episode consists of about 3-4 separate videos. This method returns a list of them.
        &#34;&#34;&#34;
        return [self.__get_video(m) for m in self.__get_mediagen()]

    def download(self, filename: Optional[str] = None, quality: str = &#39;max&#39;, ffmpeg_executable: Optional[str] = None, max_threads: int = 4):
        &#34;&#34;&#34;
        Downloads the episode to a file using a single thread. ffmpeg is required for this to work.
        :param filename: The file to save the download to. If it points to an existing directory, a new file is created in that directory following a simple name scheme and with .mp4 extension.
        :param quality: The desired quality. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39;, or a resolution like &#39;1920x1080&#39; (the closes matching resolution is taken in this case)
        :param ffmpeg_executable: The path to the ffmpeg executable, defaults to &#39;ffmpeg&#39; on unix and &#39;ffmpeg.exe&#39; on windows
        :param max_threads: The maximum number of downloads to perform concurrently.
        &#34;&#34;&#34;

        if filename is None:

            filename = f&#39;S{self.season}E{self.episode_number_in_season} - {escape_filename(self.title)}.mp4&#39;
        elif os.path.isdir(filename):
            filename = os.path.join(filename, f&#39;S{self.season}E{self.episode_number_in_season} - {escape_filename(self.title)}.mp4&#39;)

        if ffmpeg_executable is None:
            ffmpeg_executable = &#39;ffmpeg.exe&#39; if os.name == &#39;nt&#39; else &#39;ffmpeg&#39;

        log.info(&#34;Downloading Episode \&#34;%s\&#34; (S%sE%s) to %s...&#34;, self.title, self.season, self.episode_number_in_season,
                 filename)

        videos = self.get_videos()

        fns = []
        with ThreadPoolExecutor(max_workers=max_threads) as e:
            for i, vid in enumerate(videos):
                stream = vid.get_stream(quality=quality)
                fn = os.path.join(tempdir, f&#34;{self.id}--{i}.ts&#34;)
                fns.append(fn)
                log.info(&#34;Initiated download of stream #%s of %s...&#34;, i, len(videos))
                e.submit(lambda: subprocess.Popen([ffmpeg_executable, &#39;-loglevel&#39;, &#39;warning&#39;, &#39;-y&#39;, &#39;-i&#39;, stream.url, &#39;-codec&#39;, &#39;copy&#39;, fn], stdin=subprocess.PIPE).wait())

        log.info(&#34;Merging downloaded streams...&#34;)
        metadata = []
        for k, v in {
                        &#34;title&#34;: f&#34;{self.title} (S{self.season} E{self.episode_number_in_season})&#34;,
                        &#34;description&#34;: self.description,
                        &#34;comment&#34;: self.description,
                        &#34;year&#34;: time.localtime(self.date).tm_year,
                        &#34;track&#34;: self.episode_number_in_season,
                        &#34;synopsis&#34;: self.short_description,
                        &#34;show&#34;: &#34;South Park&#34;,
                        &#34;episode_id&#34;: self.episode_number,
                        &#34;album&#34;: self.season,
                        &#34;author&#34;: &#34;The South Park Team&#34;
                    }.items():
            metadata.append(&#34;-metadata&#34;)
            metadata.append(f&#39;{k}={escape_string(str(v))}&#39;)
        subprocess.Popen([ffmpeg_executable, &#39;-loglevel&#39;, &#39;warning&#39;, &#39;-y&#39;,  &#39;-i&#39;, f&#39;concat:{&#34;|&#34;.join(fns)}&#39;] + metadata + [&#39;-c:v&#39;, &#39;copy&#39;, f&#39;{filename}&#39;]).wait()

        log.info(&#34;Cleaning up...&#34;)
        for f in fns:
            os.remove(f)

        log.info(&#34;Download of Episode \&#34;%s\&#34; (S%sE%s) done.&#34;, self.title, self.season, self.episode_number_in_season)

    def __get_video(self, mediagen: str) -&gt; Video:
        if self.lang != &#34;de&#34;:
            mediagen = mediagen.replace(&#39;device={device}&#39;, &#39;device=Android&amp;deviceOsVersion=4.4.4&amp;acceptMethods=hls&#39;)
        else:
            mediagen = mediagen.replace(&#39;device={device}&#39;, &#39;acceptMethods=hls&#39;)
        xml = http_get(mediagen)
        root = etree.fromstring(xml)
        rtmpe = []
        duration = []
        captions = &#34;&#34;
        if sys.version_info &gt;= (2, 7):
            for item in root.iter(&#39;src&#39;):
                if item.text != None and not &#34;intros&#34; in item.text:
                    if self.lang == &#34;es&#34;:
                        rtmpe.append(item.text)
                    elif not &#34;acts/es&#34; in item.text:
                        rtmpe.append(item.text)
            for item in root.iter(&#39;rendition&#39;):
                if item.attrib[&#39;duration&#39;] != None:
                    duration.append(int(item.attrib[&#39;duration&#39;]))
            for item in root.iter(&#39;typographic&#39;):
                if item.attrib[&#39;src&#39;] != None and item.attrib[&#39;format&#39;] == &#34;vtt&#34;:
                    captions = item.attrib[&#39;src&#39;]
        else:
            for item in root.getiterator(&#39;src&#39;):
                if item.text != None and not &#34;intros&#34; in item.text:
                    if self.lang == &#34;es&#34;:
                        rtmpe.append(item.text)
                    elif not &#34;acts/es&#34; in item.text:
                        rtmpe.append(item.text)
            for item in root.getiterator(&#39;rendition&#39;):
                if item.attrib[&#39;duration&#39;] != None:
                    duration.append(int(item.attrib[&#39;duration&#39;]))
            for item in root.getiterator(&#39;typographic&#39;):
                if item.attrib[&#39;src&#39;] != None and item.attrib[&#39;format&#39;] == &#34;vtt&#34;:
                    captions = item.attrib[&#39;src&#39;]
        return Video(rtmpe, duration, captions)

    def __get_mediagen(self) -&gt; List[str]:
        mediagen = []
        comp = self.__mediagen_url()
        feed = http_get(comp)
        if self.lang == &#34;se&#34;:
            jsondata = json.loads(feed)
            for media in jsondata[&#34;feed&#34;][&#34;items&#34;]:
                mediagen.append(media[&#34;group&#34;][&#34;content&#34;])
        else:
            root = etree.fromstring(feed)
            if sys.version_info &gt;= (2, 7):
                for item in root.iter(&#39;{http://search.yahoo.com/mrss/}content&#39;):
                    if item.attrib[&#39;url&#39;] is not None:
                        mediagen.append(urllib.parse.unquote(item.attrib[&#39;url&#39;]))
            else:
                for item in root.getiterator(&#39;{http://search.yahoo.com/mrss/}content&#39;):
                    if item.attrib[&#39;url&#39;] is not None:
                        mediagen.append(urllib.parse.unquote(item.attrib[&#39;url&#39;]))
        return mediagen

    def __mediagen_url(self) -&gt; str:
        if self.lang == &#34;se&#34;:
            return &#34;https://media.mtvnservices.com/pmt/e1/access/index.html?uri=mgid:arc:episode:{0}:{1}&amp;configtype=edge&#34;.format(
                DOMAIN_URL[self.lang], self.id)
        return f&#34;https://{DOMAIN_REF[self.lang]}/feeds/video-player/mrss/mgid:arc:episode:{DOMAIN_URL[self.lang]}:{self.id}?lang={self.lang.upper()}&#34;

    def __str__(self):
        return f&#34;&lt;{type(self).__name__} at {id(self)} episodeId={self.id} season={self.season} episode={self.episode_number_in_season} title=\&#34;{self.title}\&#34;&gt;&#34;

    def __repr__(self):
        return str(self)

    def __lt__(self, other):
        return int(self.episode_number) &lt; int(other.episode_number)


class Season:
    def __init__(self, season_num: int, episodes: List[Episode]):
        self.season_num: int = season_num
        &#34;&#34;&#34;The season number&#34;&#34;&#34;
        self.episodes: List[Episode] = episodes
        &#34;&#34;&#34;A list of all episodes in the season&#34;&#34;&#34;

    def __str__(self):
        return f&#34;&lt;{type(self).__name__} at {id(self)} season={self.season_num} episodes={len(self.episodes)}&gt;&#34;

    def __repr__(self):
        return str(self)


class SouthPark:
    &#34;&#34;&#34;
    A simple South Park interface supporting downloads and advanced video stream management.
    &#34;&#34;&#34;

    def __init__(self, lang: str = &#39;en&#39;):
        if lang not in DOMAIN_URL:
            raise ValueError(f&#34;Unsupported language: {lang}. Supported languages are: {&#39;, &#39;.join(DOMAIN_URL.keys())}&#34;)
        self.lang = lang.lower()

    def get_season_numbers(self) -&gt; List[int]:
        &#34;&#34;&#34;
        Get a list of all season numbers of the current language.
        :return: A list containing the season numbers, as ints
        &#34;&#34;&#34;
        resp = http_get(ALL_SEASONS_URL[self.lang])
        return sorted(set([int(x.group(1)) for x in re.finditer(r&#39;data-value=&#34;season-(\d+)&#34;&#39;, resp)])) or list(range(24))

    def get_all_seasons(self) -&gt; List[Season]:
        &#34;&#34;&#34;
        Get all seasons available for the current language. This messuge performs a network request
        for each season to fetch the episode information. If you do not need this consider using `get_season(str)`
        to get a specific season alongside `get_season_numbers(str)` to get a list of all existing season numbers.
        :return: A list containing a Season object for each season
        &#34;&#34;&#34;
        for season in self.get_season_numbers():
            yield self.get_season(season)

    def get_season(self, season: int) -&gt; Season:
        &#34;&#34;&#34;
        Get a Season object for a specific south park season.
        :param season: The Season&#39;s number (as int)
        &#34;&#34;&#34;
        if self.lang == &#34;de&#34;:
            url = f&#34;https://www.southpark.de/feeds/carousel/video/e3748950-6c2a-4201-8e45-89e255c06df1/30/1/json/!airdate/season-{season}&#34;
        elif self.lang == &#34;se&#34; and season &lt; 23:  # SE doesn&#39;t have the 23rd season.
            url = f&#34;https://www.southparkstudios.nu/feeds/carousel/video/9bbbbea3-a853-4f1c-b5cf-dc6edb9d4c00/30/1/json/!airdate/season-{season}&#34;
        elif self.lang == &#34;uk&#34;:
            url = f&#34;https://www.southparkstudios.co.uk/feeds/carousel/video/02ea1fb4-2e7c-45e2-ad42-ec8a04778e64/30/1/json/!airdate/season-{season}&#34;
        # cc.com is the ony one with jsons so descriptions will be in english
        else:
            url = f&#34;https://southpark.cc.com/feeds/carousel/video/06bb4aa7-9917-4b6a-ae93-5ed7be79556a/30/1/json/!airdate/season-{season}?lang={self.lang}&#34;

        season_data = json.loads(http_get(url))

        episodes = []
        for e in season_data[&#34;results&#34;]:
            episodes.append(Episode(
                id=e.get(&#34;itemId&#34;).strip(),
                title=e.get(&#34;title&#34;).strip(),
                description=e.get(&#34;description&#34;).strip(),
                short_description=e.get(&#34;shortDescription&#34;).strip(),
                thumbnail=e.get(&#34;images&#34;).strip(),
                date=int(e.get(&#34;originalAirDate&#34;, 0).strip()),
                episode_number=e.get(&#34;episodeNumber&#34;).strip(),
                episode_number_in_season=e.get(&#34;episodeNumber&#34;, &#34;0&#34;)[-2:].strip(),
                season=e.get(&#34;episodeNumber&#34;, &#34;0&#34;)[:2].strip(),
                _lang=self.lang
            ))

        return Season(season, episodes)

    def __carousel(self, video_id: Optional[str] = None) -&gt; Dict:
        if self.lang == &#39;de&#39;:
            url = f&#34;https://www.southpark.de/feeds/carousel/video/{video_id or &#39;e3748950-6c2a-4201-8e45-89e255c06df1&#39;}/30/1/json&#34;
        elif self.lang == &#39;se&#39;:
            url = f&#34;https://www.southparkstudios.nu/feeds/carousel/wiki/{video_id or &#39;3fb9ffcb-1f70-42ed-907d-9171091a28f4&#39;}/12/1/json&#34;
        elif self.lang == &#39;uk&#39;:
            url = f&#34;https://www.southparkstudios.co.uk/feeds/carousel/wiki/{video_id or &#39;4d56eb84-60d9-417e-9550-31bbfa1e7fb9&#39;}/12/1/json&#34;
        else:
            url = f&#34;https://southpark.cc.com/feeds/carousel/video/{video_id or &#39;2b6c5ab4-d717-4e84-9143-918793a3b636&#39;}/14/2/json/!airdate/?lang={self.lang.upper()}&#34;
        return json.loads(http_get(url))


def http_get(url: str, default: Any = &#39;&#39;) -&gt; bytes:
    &#34;&#34;&#34;
    Perform a simple HTTP GET request and return the response body as bytes.
    :param url: The url to fetch
    :param default: A default value to return on network errors.
    :return: The response body, as bytes
    &#34;&#34;&#34;
    try:
        with urllib.request.urlopen(url) as resp:
            return resp.read()
    except:
        return default


def escape_filename(string: str) -&gt; str:
    &#34;&#34;&#34;
    Escape a string to put it into a file name. This removes special chars from the string that
    are not supported by the filesystem.
    :param string: The string to escape
    :return: The escaped string
    &#34;&#34;&#34;
    return &#34;&#34;.join(x if (x.isalnum() or x in &#34;._- &#34;) else &#39;_&#39; for x in string)


def escape_string(string: str) -&gt; str:
    &#34;&#34;&#34;
    Escapes a string so it can be passed via a command line argument
    :param string:  Th estring to escape
    :return: The escaped string
    &#34;&#34;&#34;

    return string.replace(&#39;&#34;&#39;, &#39;\&#34;&#39;).replace(&#34;\n&#34;, &#34;\\n&#34;).replace(&#34;\r&#34;, &#34;\\r&#34;)


def parse_episode_string(string: str) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Parses a string like &#34;S04E12&#34; into a tuple like (4, 12). Leading zeros are optional. If
    only a season number is supplied (&#34;S04&#34;), the second element in the tuple is None: (4, None)
    :param string: The season (and episode) string
    :return: The parsed tuple
    &#34;&#34;&#34;
    m = re.match(r&#39;S(\d+)(?:E(\d+))?&#39;, string.upper())
    if m:
        return int(m.group(1)), (int(m.group(2)) if m.group(2) else None)
    raise ValueError(f&#34;Invalid season/episode selector: \&#34;{string}\&#34;. Valid examples: &#39;S01&#39; or &#39;S01E03&#39;&#34;)


if __name__ == &#39;__main__&#39;:
    import argparse

    parser = argparse.ArgumentParser(os.path.basename(__file__), description=&#34;Download South Park Seasons or Episodes&#34;)
    parser.add_argument(&#39;what&#39;,
                        help=&#34;Specify what to download. Examples: &#39;all&#39;, &#39;S01&#39;, &#39;S01E02&#39;, &#39;S01-S07&#39;, &#39;S01,S02-S04,S05E01-S05E04&#39;&#34;)
    parser.add_argument(&#39;-p&#39;, &#39;--path&#39;, default=&#39;South Park/Season %s/%e - %t.mp4&#39;,
                        help=f&#34;Specify where to save downloaded episodes and how the files are called. Directories that do not exist are created automatically. &#39;%%s&#39; is replaced with the current season number, &#39;%%e&#39; with the current episode number, &#39;%%t&#39; with the episode&#39;s title and &#39;%%g&#39; with the global episode number (e.g. \&#34;1803\&#34;)&#34;)
    parser.add_argument(&#39;-l&#39;, &#39;--language&#39;, default=&#39;en&#39;,
                        help=f&#34;Set the language for the downloads. The default language is english (en). Supported languages are: {&#39;, &#39;.join(DOMAIN_URL.keys())}&#34;)
    parser.add_argument(&#39;-q&#39;, &#39;--quality&#39;, default=&#39;max&#39;,
                        help=&#34;The video quality to use for downloads. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39; or a resolution string like &#39;1920x1080&#39; to use the closest matching resolution that is available. Default: max&#34;)
    parser.add_argument(&#39;-b&#39;, &#34;--ffmpeg-binary&#34;, default=None,
                        help=&#34;Specify the path of the ffmpeg binary. Default on unix is &#39;ffmpeg&#39;, on windows it&#39;s &#39;ffmpeg.exe&#39;&#34;)
    parser.add_argument(&#39;-t&#39;, &#39;--threads&#39;, default=4, type=int,
                        help=&#34;Specify the maximum number of threads to download video parts concurrently. Default: 4&#34;)
    parser.add_argument(&#39;-f&#39;, &#39;--tempdir&#39;, default=tempdir,
                        help=&#34;Specify where to put temporary files. This option can be useful for example if you do not have enough space left on your harddrive and want to work on an external drive.&#34;)
    parser.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;store_true&#39;,
                        help=&#34;Give a more verbose output of what is currently happening.&#34;)

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.INFO)

    s = SouthPark(args.language)

    print(&#34;Collecting episodes to download...&#34;)
    to_download = []
    if args.what == &#39;all&#39;:
        for season in s.get_all_seasons():
            for e in season.episodes:
                to_download.append(e)
    else:
        for el in map(str.strip, args.what.split(&#34;,&#34;)):
            if &#39;-&#39; in el:
                if el.count(&#39;-&#39;) &gt; 1:
                    raise ValueError(f&#34;Invalid parameter: {el} in {args.what}&#34;)
                start, end = map(parse_episode_string, map(str.strip, el.split(&#34;-&#34;, 1)))
                for i in range(start[0], end[0] + 1):
                    season = s.get_season(i)
                    for e in season.episodes:
                        if start[1] is not None and i == start[0] and int(e.episode_number_in_season) &lt; start[1] \
                                or end[1] is not None and i == end[0] and int(e.episode_number_in_season) &gt; end[1]:
                            continue
                        to_download.append(e)
            else:
                season, episode = parse_episode_string(el)
                if episode is not None:
                    for e in s.get_season(season).episodes:
                        if int(e.episode_number_in_season) == episode:
                            to_download.append(e)
                            break
                    else:
                        raise ValueError(f&#34;Season {season} Episode {episode} does not exist.&#34;)
                else:
                    for e in s.get_season(season).episodes:
                        to_download.append(e)

    to_download.sort()

    print(f&#34;Downloading {len(to_download)} episode(s) from {len(set(x.season for x in to_download))} season(s).&#34;)
    print(f&#34;Language: {args.language}&#34;)
    print(f&#34;Quality:  {args.quality}&#34;)
    print(f&#34;Save to:  {args.path}&#34;)

    if input(&#34;Continue? [y/n] &#34;) in [&#34;n&#34;, &#34;no&#34;, &#34;abort&#34;, &#34;exit&#34;, &#34;stop&#34;, &#34;cancel&#34;]:
        print(&#34;Aborted by user.&#34;)
        exit()

    if os.path.isdir(args.path):
        args.path = os.path.join(args.path, &#39;Season %s/%e - %t.mp4&#39;)
    if args.tempdir != tempdir:
        set_tempdir(args.tempdir)

    for i, e in enumerate(to_download):
        path = os.path.realpath(
            args.path.replace(&#34;%s&#34;, e.season).replace(&#34;%e&#34;, e.episode_number_in_season).replace(&#34;%g&#34;, e.episode_number).replace(&#34;%t&#34;, escape_filename(e.title)))
        os.makedirs(os.path.dirname(path), exist_ok=True)

        print(f&#34;Downloading season {e.season} episode {e.episode_number_in_season} - {e.title}...&#34;)
        log.debug(&#34;Saving to: %s&#34;, path)
        try:
            e.download(path, quality=args.quality, ffmpeg_executable=args.ffmpeg_binary, max_threads=args.threads)
        except KeyboardInterrupt:
            time.sleep(0.5)
            if input(f&#34;Press return to skip only this download (S{e.season} E{e.episode_number_in_season}) or enter &#39;exit&#39; to cancel all remaining downloads.&#34;) in (&#39;exit&#39;, &#39;e&#39;, &#39;all&#39;):
                print(f&#34;Downloaded {i} episode(s) of {len(to_download)} ({round(i * 100. / len(to_download), 1)}%).&#34;)
                print(&#34;Aborted by user.&#34;)
                exit()
            if os.path.isfile(path):
                os.remove(path)
            print(f&#34;Cancelled download of season {e.season} episode {e.episode_number_in_season} - {e.title}&#34;)

    print(&#34;All done.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spdl.escape_filename"><code class="name flex">
<span>def <span class="ident">escape_filename</span></span>(<span>string: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Escape a string to put it into a file name. This removes special chars from the string that
are not supported by the filesystem.
:param string: The string to escape
:return: The escaped string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escape_filename(string: str) -&gt; str:
    &#34;&#34;&#34;
    Escape a string to put it into a file name. This removes special chars from the string that
    are not supported by the filesystem.
    :param string: The string to escape
    :return: The escaped string
    &#34;&#34;&#34;
    return &#34;&#34;.join(x if (x.isalnum() or x in &#34;._- &#34;) else &#39;_&#39; for x in string)</code></pre>
</details>
</dd>
<dt id="spdl.escape_string"><code class="name flex">
<span>def <span class="ident">escape_string</span></span>(<span>string: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Escapes a string so it can be passed via a command line argument
:param string:
Th estring to escape
:return: The escaped string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escape_string(string: str) -&gt; str:
    &#34;&#34;&#34;
    Escapes a string so it can be passed via a command line argument
    :param string:  Th estring to escape
    :return: The escaped string
    &#34;&#34;&#34;

    return string.replace(&#39;&#34;&#39;, &#39;\&#34;&#39;).replace(&#34;\n&#34;, &#34;\\n&#34;).replace(&#34;\r&#34;, &#34;\\r&#34;)</code></pre>
</details>
</dd>
<dt id="spdl.http_get"><code class="name flex">
<span>def <span class="ident">http_get</span></span>(<span>url: str, default: Any = '') -> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a simple HTTP GET request and return the response body as bytes.
:param url: The url to fetch
:param default: A default value to return on network errors.
:return: The response body, as bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def http_get(url: str, default: Any = &#39;&#39;) -&gt; bytes:
    &#34;&#34;&#34;
    Perform a simple HTTP GET request and return the response body as bytes.
    :param url: The url to fetch
    :param default: A default value to return on network errors.
    :return: The response body, as bytes
    &#34;&#34;&#34;
    try:
        with urllib.request.urlopen(url) as resp:
            return resp.read()
    except:
        return default</code></pre>
</details>
</dd>
<dt id="spdl.parse_episode_string"><code class="name flex">
<span>def <span class="ident">parse_episode_string</span></span>(<span>string: str) -> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a string like "S04E12" into a tuple like (4, 12). Leading zeros are optional. If
only a season number is supplied ("S04"), the second element in the tuple is None: (4, None)
:param string: The season (and episode) string
:return: The parsed tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_episode_string(string: str) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Parses a string like &#34;S04E12&#34; into a tuple like (4, 12). Leading zeros are optional. If
    only a season number is supplied (&#34;S04&#34;), the second element in the tuple is None: (4, None)
    :param string: The season (and episode) string
    :return: The parsed tuple
    &#34;&#34;&#34;
    m = re.match(r&#39;S(\d+)(?:E(\d+))?&#39;, string.upper())
    if m:
        return int(m.group(1)), (int(m.group(2)) if m.group(2) else None)
    raise ValueError(f&#34;Invalid season/episode selector: \&#34;{string}\&#34;. Valid examples: &#39;S01&#39; or &#39;S01E03&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="spdl.set_tempdir"><code class="name flex">
<span>def <span class="ident">set_tempdir</span></span>(<span>dir: Union[str, NoneType] = None) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the directory to put temporary files. The files are deleted automatically when the script exits.
:param dir: The temporary directory root</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tempdir(dir: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;
    Set the directory to put temporary files. The files are deleted automatically when the script exits.
    :param dir: The temporary directory root
    &#34;&#34;&#34;
    global tempdir
    tempdir = os.path.join(dir or tempfile.gettempdir(), f&#39;.spdl-{time.time()}&#39;)
    if not os.path.isdir(tempdir):
        os.mkdir(tempdir)
    atexit.register(lambda: shutil.rmtree(tempdir))
    return tempdir</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spdl.Episode"><code class="flex name class">
<span>class <span class="ident">Episode</span></span>
<span>(</span><span>id: str, title: str, description: str, short_description: str, thumbnail: str, date: float, episode_number: str, season: Union[str, NoneType] = None, episode_number_in_season: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Episode:
    def __init__(self, id: str, title: str, description: str, short_description: str, thumbnail: str, date: float,
                 episode_number: str, season: Optional[str] = None,
                 episode_number_in_season: Optional[str] = None, _lang: str = &#39;en&#39;):
        self.id: str = id
        &#34;&#34;&#34;The south park intern uid of the episode&#34;&#34;&#34;
        self.title: str = title
        &#34;&#34;&#34;The title of the episode&#34;&#34;&#34;
        self.description: str = description
        &#34;&#34;&#34;The description of the episode&#34;&#34;&#34;
        self.short_description: str = short_description
        &#34;&#34;&#34;A short description of the episode&#34;&#34;&#34;
        self.thumbnail: str = thumbnail
        &#34;&#34;&#34;A URL to the thumbnail image of the episode&#34;&#34;&#34;
        self.date: float = date
        &#34;&#34;&#34;The date of the episode as a unix timestamp&#34;&#34;&#34;
        self.episode_number: str = episode_number
        &#34;&#34;&#34;The global episode number, e.g. &#34;1908&#34; or &#34;2001\&#34;&#34;&#34;&#34;
        self.season: str = season
        &#34;&#34;&#34;The number of the season the episode belongs to&#34;&#34;&#34;
        self.episode_number_in_season: str = episode_number_in_season
        &#34;&#34;&#34;The episode number relative to it&#39;s season, e.g. &#34;06\&#34;&#34;&#34;&#34;
        self.lang: str = _lang
        &#34;&#34;&#34;The language of the episode, inherited from the SouthPark constructor&#34;&#34;&#34;

    def get_videos(self) -&gt; List[Video]:
        &#34;&#34;&#34;
        Each south park episode consists of about 3-4 separate videos. This method returns a list of them.
        &#34;&#34;&#34;
        return [self.__get_video(m) for m in self.__get_mediagen()]

    def download(self, filename: Optional[str] = None, quality: str = &#39;max&#39;, ffmpeg_executable: Optional[str] = None, max_threads: int = 4):
        &#34;&#34;&#34;
        Downloads the episode to a file using a single thread. ffmpeg is required for this to work.
        :param filename: The file to save the download to. If it points to an existing directory, a new file is created in that directory following a simple name scheme and with .mp4 extension.
        :param quality: The desired quality. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39;, or a resolution like &#39;1920x1080&#39; (the closes matching resolution is taken in this case)
        :param ffmpeg_executable: The path to the ffmpeg executable, defaults to &#39;ffmpeg&#39; on unix and &#39;ffmpeg.exe&#39; on windows
        :param max_threads: The maximum number of downloads to perform concurrently.
        &#34;&#34;&#34;

        if filename is None:

            filename = f&#39;S{self.season}E{self.episode_number_in_season} - {escape_filename(self.title)}.mp4&#39;
        elif os.path.isdir(filename):
            filename = os.path.join(filename, f&#39;S{self.season}E{self.episode_number_in_season} - {escape_filename(self.title)}.mp4&#39;)

        if ffmpeg_executable is None:
            ffmpeg_executable = &#39;ffmpeg.exe&#39; if os.name == &#39;nt&#39; else &#39;ffmpeg&#39;

        log.info(&#34;Downloading Episode \&#34;%s\&#34; (S%sE%s) to %s...&#34;, self.title, self.season, self.episode_number_in_season,
                 filename)

        videos = self.get_videos()

        fns = []
        with ThreadPoolExecutor(max_workers=max_threads) as e:
            for i, vid in enumerate(videos):
                stream = vid.get_stream(quality=quality)
                fn = os.path.join(tempdir, f&#34;{self.id}--{i}.ts&#34;)
                fns.append(fn)
                log.info(&#34;Initiated download of stream #%s of %s...&#34;, i, len(videos))
                e.submit(lambda: subprocess.Popen([ffmpeg_executable, &#39;-loglevel&#39;, &#39;warning&#39;, &#39;-y&#39;, &#39;-i&#39;, stream.url, &#39;-codec&#39;, &#39;copy&#39;, fn], stdin=subprocess.PIPE).wait())

        log.info(&#34;Merging downloaded streams...&#34;)
        metadata = []
        for k, v in {
                        &#34;title&#34;: f&#34;{self.title} (S{self.season} E{self.episode_number_in_season})&#34;,
                        &#34;description&#34;: self.description,
                        &#34;comment&#34;: self.description,
                        &#34;year&#34;: time.localtime(self.date).tm_year,
                        &#34;track&#34;: self.episode_number_in_season,
                        &#34;synopsis&#34;: self.short_description,
                        &#34;show&#34;: &#34;South Park&#34;,
                        &#34;episode_id&#34;: self.episode_number,
                        &#34;album&#34;: self.season,
                        &#34;author&#34;: &#34;The South Park Team&#34;
                    }.items():
            metadata.append(&#34;-metadata&#34;)
            metadata.append(f&#39;{k}={escape_string(str(v))}&#39;)
        subprocess.Popen([ffmpeg_executable, &#39;-loglevel&#39;, &#39;warning&#39;, &#39;-y&#39;,  &#39;-i&#39;, f&#39;concat:{&#34;|&#34;.join(fns)}&#39;] + metadata + [&#39;-c:v&#39;, &#39;copy&#39;, f&#39;{filename}&#39;]).wait()

        log.info(&#34;Cleaning up...&#34;)
        for f in fns:
            os.remove(f)

        log.info(&#34;Download of Episode \&#34;%s\&#34; (S%sE%s) done.&#34;, self.title, self.season, self.episode_number_in_season)

    def __get_video(self, mediagen: str) -&gt; Video:
        if self.lang != &#34;de&#34;:
            mediagen = mediagen.replace(&#39;device={device}&#39;, &#39;device=Android&amp;deviceOsVersion=4.4.4&amp;acceptMethods=hls&#39;)
        else:
            mediagen = mediagen.replace(&#39;device={device}&#39;, &#39;acceptMethods=hls&#39;)
        xml = http_get(mediagen)
        root = etree.fromstring(xml)
        rtmpe = []
        duration = []
        captions = &#34;&#34;
        if sys.version_info &gt;= (2, 7):
            for item in root.iter(&#39;src&#39;):
                if item.text != None and not &#34;intros&#34; in item.text:
                    if self.lang == &#34;es&#34;:
                        rtmpe.append(item.text)
                    elif not &#34;acts/es&#34; in item.text:
                        rtmpe.append(item.text)
            for item in root.iter(&#39;rendition&#39;):
                if item.attrib[&#39;duration&#39;] != None:
                    duration.append(int(item.attrib[&#39;duration&#39;]))
            for item in root.iter(&#39;typographic&#39;):
                if item.attrib[&#39;src&#39;] != None and item.attrib[&#39;format&#39;] == &#34;vtt&#34;:
                    captions = item.attrib[&#39;src&#39;]
        else:
            for item in root.getiterator(&#39;src&#39;):
                if item.text != None and not &#34;intros&#34; in item.text:
                    if self.lang == &#34;es&#34;:
                        rtmpe.append(item.text)
                    elif not &#34;acts/es&#34; in item.text:
                        rtmpe.append(item.text)
            for item in root.getiterator(&#39;rendition&#39;):
                if item.attrib[&#39;duration&#39;] != None:
                    duration.append(int(item.attrib[&#39;duration&#39;]))
            for item in root.getiterator(&#39;typographic&#39;):
                if item.attrib[&#39;src&#39;] != None and item.attrib[&#39;format&#39;] == &#34;vtt&#34;:
                    captions = item.attrib[&#39;src&#39;]
        return Video(rtmpe, duration, captions)

    def __get_mediagen(self) -&gt; List[str]:
        mediagen = []
        comp = self.__mediagen_url()
        feed = http_get(comp)
        if self.lang == &#34;se&#34;:
            jsondata = json.loads(feed)
            for media in jsondata[&#34;feed&#34;][&#34;items&#34;]:
                mediagen.append(media[&#34;group&#34;][&#34;content&#34;])
        else:
            root = etree.fromstring(feed)
            if sys.version_info &gt;= (2, 7):
                for item in root.iter(&#39;{http://search.yahoo.com/mrss/}content&#39;):
                    if item.attrib[&#39;url&#39;] is not None:
                        mediagen.append(urllib.parse.unquote(item.attrib[&#39;url&#39;]))
            else:
                for item in root.getiterator(&#39;{http://search.yahoo.com/mrss/}content&#39;):
                    if item.attrib[&#39;url&#39;] is not None:
                        mediagen.append(urllib.parse.unquote(item.attrib[&#39;url&#39;]))
        return mediagen

    def __mediagen_url(self) -&gt; str:
        if self.lang == &#34;se&#34;:
            return &#34;https://media.mtvnservices.com/pmt/e1/access/index.html?uri=mgid:arc:episode:{0}:{1}&amp;configtype=edge&#34;.format(
                DOMAIN_URL[self.lang], self.id)
        return f&#34;https://{DOMAIN_REF[self.lang]}/feeds/video-player/mrss/mgid:arc:episode:{DOMAIN_URL[self.lang]}:{self.id}?lang={self.lang.upper()}&#34;

    def __str__(self):
        return f&#34;&lt;{type(self).__name__} at {id(self)} episodeId={self.id} season={self.season} episode={self.episode_number_in_season} title=\&#34;{self.title}\&#34;&gt;&#34;

    def __repr__(self):
        return str(self)

    def __lt__(self, other):
        return int(self.episode_number) &lt; int(other.episode_number)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spdl.Episode.date"><code class="name">var <span class="ident">date</span></code></dt>
<dd>
<div class="desc"><p>The date of the episode as a unix timestamp</p></div>
</dd>
<dt id="spdl.Episode.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"><p>The description of the episode</p></div>
</dd>
<dt id="spdl.Episode.episode_number"><code class="name">var <span class="ident">episode_number</span></code></dt>
<dd>
<div class="desc"><p>The global episode number, e.g. "1908" or "2001"</p></div>
</dd>
<dt id="spdl.Episode.episode_number_in_season"><code class="name">var <span class="ident">episode_number_in_season</span></code></dt>
<dd>
<div class="desc"><p>The episode number relative to it's season, e.g. "06"</p></div>
</dd>
<dt id="spdl.Episode.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The south park intern uid of the episode</p></div>
</dd>
<dt id="spdl.Episode.lang"><code class="name">var <span class="ident">lang</span></code></dt>
<dd>
<div class="desc"><p>The language of the episode, inherited from the SouthPark constructor</p></div>
</dd>
<dt id="spdl.Episode.season"><code class="name">var <span class="ident">season</span></code></dt>
<dd>
<div class="desc"><p>The number of the season the episode belongs to</p></div>
</dd>
<dt id="spdl.Episode.short_description"><code class="name">var <span class="ident">short_description</span></code></dt>
<dd>
<div class="desc"><p>A short description of the episode</p></div>
</dd>
<dt id="spdl.Episode.thumbnail"><code class="name">var <span class="ident">thumbnail</span></code></dt>
<dd>
<div class="desc"><p>A URL to the thumbnail image of the episode</p></div>
</dd>
<dt id="spdl.Episode.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title of the episode</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spdl.Episode.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, filename: Union[str, NoneType] = None, quality: str = 'max', ffmpeg_executable: Union[str, NoneType] = None, max_threads: int = 4)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads the episode to a file using a single thread. ffmpeg is required for this to work.
:param filename: The file to save the download to. If it points to an existing directory, a new file is created in that directory following a simple name scheme and with .mp4 extension.
:param quality: The desired quality. Either 'max', 'medium', 'min', or a resolution like '1920x1080' (the closes matching resolution is taken in this case)
:param ffmpeg_executable: The path to the ffmpeg executable, defaults to 'ffmpeg' on unix and 'ffmpeg.exe' on windows
:param max_threads: The maximum number of downloads to perform concurrently.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, filename: Optional[str] = None, quality: str = &#39;max&#39;, ffmpeg_executable: Optional[str] = None, max_threads: int = 4):
    &#34;&#34;&#34;
    Downloads the episode to a file using a single thread. ffmpeg is required for this to work.
    :param filename: The file to save the download to. If it points to an existing directory, a new file is created in that directory following a simple name scheme and with .mp4 extension.
    :param quality: The desired quality. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39;, or a resolution like &#39;1920x1080&#39; (the closes matching resolution is taken in this case)
    :param ffmpeg_executable: The path to the ffmpeg executable, defaults to &#39;ffmpeg&#39; on unix and &#39;ffmpeg.exe&#39; on windows
    :param max_threads: The maximum number of downloads to perform concurrently.
    &#34;&#34;&#34;

    if filename is None:

        filename = f&#39;S{self.season}E{self.episode_number_in_season} - {escape_filename(self.title)}.mp4&#39;
    elif os.path.isdir(filename):
        filename = os.path.join(filename, f&#39;S{self.season}E{self.episode_number_in_season} - {escape_filename(self.title)}.mp4&#39;)

    if ffmpeg_executable is None:
        ffmpeg_executable = &#39;ffmpeg.exe&#39; if os.name == &#39;nt&#39; else &#39;ffmpeg&#39;

    log.info(&#34;Downloading Episode \&#34;%s\&#34; (S%sE%s) to %s...&#34;, self.title, self.season, self.episode_number_in_season,
             filename)

    videos = self.get_videos()

    fns = []
    with ThreadPoolExecutor(max_workers=max_threads) as e:
        for i, vid in enumerate(videos):
            stream = vid.get_stream(quality=quality)
            fn = os.path.join(tempdir, f&#34;{self.id}--{i}.ts&#34;)
            fns.append(fn)
            log.info(&#34;Initiated download of stream #%s of %s...&#34;, i, len(videos))
            e.submit(lambda: subprocess.Popen([ffmpeg_executable, &#39;-loglevel&#39;, &#39;warning&#39;, &#39;-y&#39;, &#39;-i&#39;, stream.url, &#39;-codec&#39;, &#39;copy&#39;, fn], stdin=subprocess.PIPE).wait())

    log.info(&#34;Merging downloaded streams...&#34;)
    metadata = []
    for k, v in {
                    &#34;title&#34;: f&#34;{self.title} (S{self.season} E{self.episode_number_in_season})&#34;,
                    &#34;description&#34;: self.description,
                    &#34;comment&#34;: self.description,
                    &#34;year&#34;: time.localtime(self.date).tm_year,
                    &#34;track&#34;: self.episode_number_in_season,
                    &#34;synopsis&#34;: self.short_description,
                    &#34;show&#34;: &#34;South Park&#34;,
                    &#34;episode_id&#34;: self.episode_number,
                    &#34;album&#34;: self.season,
                    &#34;author&#34;: &#34;The South Park Team&#34;
                }.items():
        metadata.append(&#34;-metadata&#34;)
        metadata.append(f&#39;{k}={escape_string(str(v))}&#39;)
    subprocess.Popen([ffmpeg_executable, &#39;-loglevel&#39;, &#39;warning&#39;, &#39;-y&#39;,  &#39;-i&#39;, f&#39;concat:{&#34;|&#34;.join(fns)}&#39;] + metadata + [&#39;-c:v&#39;, &#39;copy&#39;, f&#39;{filename}&#39;]).wait()

    log.info(&#34;Cleaning up...&#34;)
    for f in fns:
        os.remove(f)

    log.info(&#34;Download of Episode \&#34;%s\&#34; (S%sE%s) done.&#34;, self.title, self.season, self.episode_number_in_season)</code></pre>
</details>
</dd>
<dt id="spdl.Episode.get_videos"><code class="name flex">
<span>def <span class="ident">get_videos</span></span>(<span>self) -> List[<a title="spdl.Video" href="#spdl.Video">Video</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Each south park episode consists of about 3-4 separate videos. This method returns a list of them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_videos(self) -&gt; List[Video]:
    &#34;&#34;&#34;
    Each south park episode consists of about 3-4 separate videos. This method returns a list of them.
    &#34;&#34;&#34;
    return [self.__get_video(m) for m in self.__get_mediagen()]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spdl.Season"><code class="flex name class">
<span>class <span class="ident">Season</span></span>
<span>(</span><span>season_num: int, episodes: List[<a title="spdl.Episode" href="#spdl.Episode">Episode</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Season:
    def __init__(self, season_num: int, episodes: List[Episode]):
        self.season_num: int = season_num
        &#34;&#34;&#34;The season number&#34;&#34;&#34;
        self.episodes: List[Episode] = episodes
        &#34;&#34;&#34;A list of all episodes in the season&#34;&#34;&#34;

    def __str__(self):
        return f&#34;&lt;{type(self).__name__} at {id(self)} season={self.season_num} episodes={len(self.episodes)}&gt;&#34;

    def __repr__(self):
        return str(self)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spdl.Season.episodes"><code class="name">var <span class="ident">episodes</span></code></dt>
<dd>
<div class="desc"><p>A list of all episodes in the season</p></div>
</dd>
<dt id="spdl.Season.season_num"><code class="name">var <span class="ident">season_num</span></code></dt>
<dd>
<div class="desc"><p>The season number</p></div>
</dd>
</dl>
</dd>
<dt id="spdl.SouthPark"><code class="flex name class">
<span>class <span class="ident">SouthPark</span></span>
<span>(</span><span>lang: str = 'en')</span>
</code></dt>
<dd>
<div class="desc"><p>A simple South Park interface supporting downloads and advanced video stream management.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SouthPark:
    &#34;&#34;&#34;
    A simple South Park interface supporting downloads and advanced video stream management.
    &#34;&#34;&#34;

    def __init__(self, lang: str = &#39;en&#39;):
        if lang not in DOMAIN_URL:
            raise ValueError(f&#34;Unsupported language: {lang}. Supported languages are: {&#39;, &#39;.join(DOMAIN_URL.keys())}&#34;)
        self.lang = lang.lower()

    def get_season_numbers(self) -&gt; List[int]:
        &#34;&#34;&#34;
        Get a list of all season numbers of the current language.
        :return: A list containing the season numbers, as ints
        &#34;&#34;&#34;
        resp = http_get(ALL_SEASONS_URL[self.lang])
        return sorted(set([int(x.group(1)) for x in re.finditer(r&#39;data-value=&#34;season-(\d+)&#34;&#39;, resp)])) or list(range(24))

    def get_all_seasons(self) -&gt; List[Season]:
        &#34;&#34;&#34;
        Get all seasons available for the current language. This messuge performs a network request
        for each season to fetch the episode information. If you do not need this consider using `get_season(str)`
        to get a specific season alongside `get_season_numbers(str)` to get a list of all existing season numbers.
        :return: A list containing a Season object for each season
        &#34;&#34;&#34;
        for season in self.get_season_numbers():
            yield self.get_season(season)

    def get_season(self, season: int) -&gt; Season:
        &#34;&#34;&#34;
        Get a Season object for a specific south park season.
        :param season: The Season&#39;s number (as int)
        &#34;&#34;&#34;
        if self.lang == &#34;de&#34;:
            url = f&#34;https://www.southpark.de/feeds/carousel/video/e3748950-6c2a-4201-8e45-89e255c06df1/30/1/json/!airdate/season-{season}&#34;
        elif self.lang == &#34;se&#34; and season &lt; 23:  # SE doesn&#39;t have the 23rd season.
            url = f&#34;https://www.southparkstudios.nu/feeds/carousel/video/9bbbbea3-a853-4f1c-b5cf-dc6edb9d4c00/30/1/json/!airdate/season-{season}&#34;
        elif self.lang == &#34;uk&#34;:
            url = f&#34;https://www.southparkstudios.co.uk/feeds/carousel/video/02ea1fb4-2e7c-45e2-ad42-ec8a04778e64/30/1/json/!airdate/season-{season}&#34;
        # cc.com is the ony one with jsons so descriptions will be in english
        else:
            url = f&#34;https://southpark.cc.com/feeds/carousel/video/06bb4aa7-9917-4b6a-ae93-5ed7be79556a/30/1/json/!airdate/season-{season}?lang={self.lang}&#34;

        season_data = json.loads(http_get(url))

        episodes = []
        for e in season_data[&#34;results&#34;]:
            episodes.append(Episode(
                id=e.get(&#34;itemId&#34;).strip(),
                title=e.get(&#34;title&#34;).strip(),
                description=e.get(&#34;description&#34;).strip(),
                short_description=e.get(&#34;shortDescription&#34;).strip(),
                thumbnail=e.get(&#34;images&#34;).strip(),
                date=int(e.get(&#34;originalAirDate&#34;, 0).strip()),
                episode_number=e.get(&#34;episodeNumber&#34;).strip(),
                episode_number_in_season=e.get(&#34;episodeNumber&#34;, &#34;0&#34;)[-2:].strip(),
                season=e.get(&#34;episodeNumber&#34;, &#34;0&#34;)[:2].strip(),
                _lang=self.lang
            ))

        return Season(season, episodes)

    def __carousel(self, video_id: Optional[str] = None) -&gt; Dict:
        if self.lang == &#39;de&#39;:
            url = f&#34;https://www.southpark.de/feeds/carousel/video/{video_id or &#39;e3748950-6c2a-4201-8e45-89e255c06df1&#39;}/30/1/json&#34;
        elif self.lang == &#39;se&#39;:
            url = f&#34;https://www.southparkstudios.nu/feeds/carousel/wiki/{video_id or &#39;3fb9ffcb-1f70-42ed-907d-9171091a28f4&#39;}/12/1/json&#34;
        elif self.lang == &#39;uk&#39;:
            url = f&#34;https://www.southparkstudios.co.uk/feeds/carousel/wiki/{video_id or &#39;4d56eb84-60d9-417e-9550-31bbfa1e7fb9&#39;}/12/1/json&#34;
        else:
            url = f&#34;https://southpark.cc.com/feeds/carousel/video/{video_id or &#39;2b6c5ab4-d717-4e84-9143-918793a3b636&#39;}/14/2/json/!airdate/?lang={self.lang.upper()}&#34;
        return json.loads(http_get(url))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spdl.SouthPark.get_all_seasons"><code class="name flex">
<span>def <span class="ident">get_all_seasons</span></span>(<span>self) -> List[<a title="spdl.Season" href="#spdl.Season">Season</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all seasons available for the current language. This messuge performs a network request
for each season to fetch the episode information. If you do not need this consider using <code>get_season(str)</code>
to get a specific season alongside <code>get_season_numbers(str)</code> to get a list of all existing season numbers.
:return: A list containing a Season object for each season</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_seasons(self) -&gt; List[Season]:
    &#34;&#34;&#34;
    Get all seasons available for the current language. This messuge performs a network request
    for each season to fetch the episode information. If you do not need this consider using `get_season(str)`
    to get a specific season alongside `get_season_numbers(str)` to get a list of all existing season numbers.
    :return: A list containing a Season object for each season
    &#34;&#34;&#34;
    for season in self.get_season_numbers():
        yield self.get_season(season)</code></pre>
</details>
</dd>
<dt id="spdl.SouthPark.get_season"><code class="name flex">
<span>def <span class="ident">get_season</span></span>(<span>self, season: int) -> <a title="spdl.Season" href="#spdl.Season">Season</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a Season object for a specific south park season.
:param season: The Season's number (as int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_season(self, season: int) -&gt; Season:
    &#34;&#34;&#34;
    Get a Season object for a specific south park season.
    :param season: The Season&#39;s number (as int)
    &#34;&#34;&#34;
    if self.lang == &#34;de&#34;:
        url = f&#34;https://www.southpark.de/feeds/carousel/video/e3748950-6c2a-4201-8e45-89e255c06df1/30/1/json/!airdate/season-{season}&#34;
    elif self.lang == &#34;se&#34; and season &lt; 23:  # SE doesn&#39;t have the 23rd season.
        url = f&#34;https://www.southparkstudios.nu/feeds/carousel/video/9bbbbea3-a853-4f1c-b5cf-dc6edb9d4c00/30/1/json/!airdate/season-{season}&#34;
    elif self.lang == &#34;uk&#34;:
        url = f&#34;https://www.southparkstudios.co.uk/feeds/carousel/video/02ea1fb4-2e7c-45e2-ad42-ec8a04778e64/30/1/json/!airdate/season-{season}&#34;
    # cc.com is the ony one with jsons so descriptions will be in english
    else:
        url = f&#34;https://southpark.cc.com/feeds/carousel/video/06bb4aa7-9917-4b6a-ae93-5ed7be79556a/30/1/json/!airdate/season-{season}?lang={self.lang}&#34;

    season_data = json.loads(http_get(url))

    episodes = []
    for e in season_data[&#34;results&#34;]:
        episodes.append(Episode(
            id=e.get(&#34;itemId&#34;).strip(),
            title=e.get(&#34;title&#34;).strip(),
            description=e.get(&#34;description&#34;).strip(),
            short_description=e.get(&#34;shortDescription&#34;).strip(),
            thumbnail=e.get(&#34;images&#34;).strip(),
            date=int(e.get(&#34;originalAirDate&#34;, 0).strip()),
            episode_number=e.get(&#34;episodeNumber&#34;).strip(),
            episode_number_in_season=e.get(&#34;episodeNumber&#34;, &#34;0&#34;)[-2:].strip(),
            season=e.get(&#34;episodeNumber&#34;, &#34;0&#34;)[:2].strip(),
            _lang=self.lang
        ))

    return Season(season, episodes)</code></pre>
</details>
</dd>
<dt id="spdl.SouthPark.get_season_numbers"><code class="name flex">
<span>def <span class="ident">get_season_numbers</span></span>(<span>self) -> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of all season numbers of the current language.
:return: A list containing the season numbers, as ints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_season_numbers(self) -&gt; List[int]:
    &#34;&#34;&#34;
    Get a list of all season numbers of the current language.
    :return: A list containing the season numbers, as ints
    &#34;&#34;&#34;
    resp = http_get(ALL_SEASONS_URL[self.lang])
    return sorted(set([int(x.group(1)) for x in re.finditer(r&#39;data-value=&#34;season-(\d+)&#34;&#39;, resp)])) or list(range(24))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spdl.Stream"><code class="flex name class">
<span>class <span class="ident">Stream</span></span>
<span>(</span><span>resolution: str, url: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stream(object):
    def __init__(self, resolution: str, url: str):
        self.url: str = url
        &#34;&#34;&#34;The url of the stream.&#34;&#34;&#34;
        self.resolution: str = resolution
        &#34;&#34;&#34;The resolution of the stream as a string in the format \&#34;1920x1080\&#34;&#34;&#34;&#34;

    def __str__(self):
        return f&#34;&lt;{type(self).__name__} at {id(self)} resolution={self.resolution} url=\&#34;{self.url}\&#34;&gt;&#34;

    def __repr__(self):
        return str(self)

    def __lt__(self, other):
        return int(self.resolution.split(&#34;x&#34;)[0]) &lt; int(other.resolution.split(&#34;x&#34;)[0])</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spdl.Stream.resolution"><code class="name">var <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"><p>The resolution of the stream as a string in the format "1920x1080"</p></div>
</dd>
<dt id="spdl.Stream.url"><code class="name">var <span class="ident">url</span></code></dt>
<dd>
<div class="desc"><p>The url of the stream.</p></div>
</dd>
</dl>
</dd>
<dt id="spdl.Video"><code class="flex name class">
<span>class <span class="ident">Video</span></span>
<span>(</span><span>streams: List[str], duration: List[int], captions: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Video:
    RTMP_STREAMS = [
        &#34;rtmpe://viacommtvstrmfs.fplive.net:1935/viacommtvstrm&#34;,
        &#34;rtmpe://cp75298.edgefcs.net/ondemand&#34;
    ]

    def __init__(self, streams: List[str], duration: List[int], captions: str):
        self.__streams = streams
        self.duration: List[int] = duration
        &#34;&#34;&#34;The duration of the video&#34;&#34;&#34;
        self.captions: str = captions
        &#34;&#34;&#34;Sub-titles for the video&#34;&#34;&#34;

    def __rtmp_streams(self, index: int = 0) -&gt; str:
        return self.RTMP_STREAMS[index]

    def get_streams(self) -&gt; List[Stream]:
        &#34;&#34;&#34;
        Get a list of streams in different qualities for this Video. The list is sorted by the
        stream quality in descending order, so that you can easily retrieve the highest quality stream
        using the first element.
        &#34;&#34;&#34;
        p = http_get(self.get_play_data()[1])
        streams = []
        curr_res = None
        for line in p.splitlines():
            if line.startswith(b&#34;#EXT-X-STREAM-INF:&#34;):
                curr_res = re.search(rb&#39;RESOLUTION=(\d+x\d+)&#39;, line).group(1)
            elif not line.startswith(b&#34;#&#34;) and line.strip():
                streams.append(Stream(curr_res.decode(&#34;utf-8&#34;), line.decode(&#34;utf-8&#34;)))
        return sorted(streams, reverse=True)

    def get_stream(self, quality: str = &#39;max&#39;) -&gt; Stream:
        &#34;&#34;&#34;
        Returns a single stream for this video.
        :param quality: The desired quality. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39;, or a resolution like &#39;1920x1080&#39; (the closes matching resolution is taken in this case)
        :return: The Stream object
        &#34;&#34;&#34;
        streams = self.get_streams()
        if quality == &#39;max&#39;:
            return streams[0]
        elif quality == &#39;min&#39;:
            return streams[-1]
        elif quality == &#39;medium&#39;:
            return streams[len(streams) // 2]
        elif re.match(r&#34;\d+x\d+$&#34;, quality):
            q = int(quality.split(&#34;x&#34;)[0]) * int(quality.split(&#34;x&#34;)[0])
            streams = sorted(streams,
                             key=lambda s: abs(q - int(s.resolution.split(&#34;x&#34;)[0]) * int(s.resolution.split(&#34;x&#34;)[0])))
            return streams[0]
        else:
            raise ValueError(
                f&#34;Invalid quality string: \&#34;{quality}\&#34;. Use one of &#39;max&#39;, &#39;medium&#39;, &#39;min&#39; or a resolution like &#39;1920x1080&#39;&#34;)

    def get_play_data(self) -&gt; Tuple[str, str]:
        ## High quality is the last stream  (-1)
        vqual = -1
        rtmp = self.__streams[vqual]
        playpath = &#34;&#34;
        if &#34;http&#34; not in rtmp:
            if &#34;viacomccstrm&#34; in self.__streams[vqual]:
                playpath = &#34;mp4:{0}&#34;.format(self.__streams[vqual].split(&#39;viacomccstrm/&#39;)[1])
                rtmp = self.__rtmp_streams()
            elif &#34;cp9950.edgefcs.net&#34; in self.__streams[vqual]:
                playpath = &#34;mp4:{0}&#34;.format(self.__streams[vqual].split(&#39;mtvnorigin/&#39;)[1])
                rtmp = self.__rtmp_streams()
        return playpath, rtmp</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spdl.Video.RTMP_STREAMS"><code class="name">var <span class="ident">RTMP_STREAMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spdl.Video.captions"><code class="name">var <span class="ident">captions</span></code></dt>
<dd>
<div class="desc"><p>Sub-titles for the video</p></div>
</dd>
<dt id="spdl.Video.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<div class="desc"><p>The duration of the video</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spdl.Video.get_play_data"><code class="name flex">
<span>def <span class="ident">get_play_data</span></span>(<span>self) -> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_play_data(self) -&gt; Tuple[str, str]:
    ## High quality is the last stream  (-1)
    vqual = -1
    rtmp = self.__streams[vqual]
    playpath = &#34;&#34;
    if &#34;http&#34; not in rtmp:
        if &#34;viacomccstrm&#34; in self.__streams[vqual]:
            playpath = &#34;mp4:{0}&#34;.format(self.__streams[vqual].split(&#39;viacomccstrm/&#39;)[1])
            rtmp = self.__rtmp_streams()
        elif &#34;cp9950.edgefcs.net&#34; in self.__streams[vqual]:
            playpath = &#34;mp4:{0}&#34;.format(self.__streams[vqual].split(&#39;mtvnorigin/&#39;)[1])
            rtmp = self.__rtmp_streams()
    return playpath, rtmp</code></pre>
</details>
</dd>
<dt id="spdl.Video.get_stream"><code class="name flex">
<span>def <span class="ident">get_stream</span></span>(<span>self, quality: str = 'max') -> <a title="spdl.Stream" href="#spdl.Stream">Stream</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a single stream for this video.
:param quality: The desired quality. Either 'max', 'medium', 'min', or a resolution like '1920x1080' (the closes matching resolution is taken in this case)
:return: The Stream object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream(self, quality: str = &#39;max&#39;) -&gt; Stream:
    &#34;&#34;&#34;
    Returns a single stream for this video.
    :param quality: The desired quality. Either &#39;max&#39;, &#39;medium&#39;, &#39;min&#39;, or a resolution like &#39;1920x1080&#39; (the closes matching resolution is taken in this case)
    :return: The Stream object
    &#34;&#34;&#34;
    streams = self.get_streams()
    if quality == &#39;max&#39;:
        return streams[0]
    elif quality == &#39;min&#39;:
        return streams[-1]
    elif quality == &#39;medium&#39;:
        return streams[len(streams) // 2]
    elif re.match(r&#34;\d+x\d+$&#34;, quality):
        q = int(quality.split(&#34;x&#34;)[0]) * int(quality.split(&#34;x&#34;)[0])
        streams = sorted(streams,
                         key=lambda s: abs(q - int(s.resolution.split(&#34;x&#34;)[0]) * int(s.resolution.split(&#34;x&#34;)[0])))
        return streams[0]
    else:
        raise ValueError(
            f&#34;Invalid quality string: \&#34;{quality}\&#34;. Use one of &#39;max&#39;, &#39;medium&#39;, &#39;min&#39; or a resolution like &#39;1920x1080&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="spdl.Video.get_streams"><code class="name flex">
<span>def <span class="ident">get_streams</span></span>(<span>self) -> List[<a title="spdl.Stream" href="#spdl.Stream">Stream</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of streams in different qualities for this Video. The list is sorted by the
stream quality in descending order, so that you can easily retrieve the highest quality stream
using the first element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_streams(self) -&gt; List[Stream]:
    &#34;&#34;&#34;
    Get a list of streams in different qualities for this Video. The list is sorted by the
    stream quality in descending order, so that you can easily retrieve the highest quality stream
    using the first element.
    &#34;&#34;&#34;
    p = http_get(self.get_play_data()[1])
    streams = []
    curr_res = None
    for line in p.splitlines():
        if line.startswith(b&#34;#EXT-X-STREAM-INF:&#34;):
            curr_res = re.search(rb&#39;RESOLUTION=(\d+x\d+)&#39;, line).group(1)
        elif not line.startswith(b&#34;#&#34;) and line.strip():
            streams.append(Stream(curr_res.decode(&#34;utf-8&#34;), line.decode(&#34;utf-8&#34;)))
    return sorted(streams, reverse=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spdl.escape_filename" href="#spdl.escape_filename">escape_filename</a></code></li>
<li><code><a title="spdl.escape_string" href="#spdl.escape_string">escape_string</a></code></li>
<li><code><a title="spdl.http_get" href="#spdl.http_get">http_get</a></code></li>
<li><code><a title="spdl.parse_episode_string" href="#spdl.parse_episode_string">parse_episode_string</a></code></li>
<li><code><a title="spdl.set_tempdir" href="#spdl.set_tempdir">set_tempdir</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spdl.Episode" href="#spdl.Episode">Episode</a></code></h4>
<ul class="">
<li><code><a title="spdl.Episode.date" href="#spdl.Episode.date">date</a></code></li>
<li><code><a title="spdl.Episode.description" href="#spdl.Episode.description">description</a></code></li>
<li><code><a title="spdl.Episode.download" href="#spdl.Episode.download">download</a></code></li>
<li><code><a title="spdl.Episode.episode_number" href="#spdl.Episode.episode_number">episode_number</a></code></li>
<li><code><a title="spdl.Episode.episode_number_in_season" href="#spdl.Episode.episode_number_in_season">episode_number_in_season</a></code></li>
<li><code><a title="spdl.Episode.get_videos" href="#spdl.Episode.get_videos">get_videos</a></code></li>
<li><code><a title="spdl.Episode.id" href="#spdl.Episode.id">id</a></code></li>
<li><code><a title="spdl.Episode.lang" href="#spdl.Episode.lang">lang</a></code></li>
<li><code><a title="spdl.Episode.season" href="#spdl.Episode.season">season</a></code></li>
<li><code><a title="spdl.Episode.short_description" href="#spdl.Episode.short_description">short_description</a></code></li>
<li><code><a title="spdl.Episode.thumbnail" href="#spdl.Episode.thumbnail">thumbnail</a></code></li>
<li><code><a title="spdl.Episode.title" href="#spdl.Episode.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spdl.Season" href="#spdl.Season">Season</a></code></h4>
<ul class="">
<li><code><a title="spdl.Season.episodes" href="#spdl.Season.episodes">episodes</a></code></li>
<li><code><a title="spdl.Season.season_num" href="#spdl.Season.season_num">season_num</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spdl.SouthPark" href="#spdl.SouthPark">SouthPark</a></code></h4>
<ul class="">
<li><code><a title="spdl.SouthPark.get_all_seasons" href="#spdl.SouthPark.get_all_seasons">get_all_seasons</a></code></li>
<li><code><a title="spdl.SouthPark.get_season" href="#spdl.SouthPark.get_season">get_season</a></code></li>
<li><code><a title="spdl.SouthPark.get_season_numbers" href="#spdl.SouthPark.get_season_numbers">get_season_numbers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spdl.Stream" href="#spdl.Stream">Stream</a></code></h4>
<ul class="">
<li><code><a title="spdl.Stream.resolution" href="#spdl.Stream.resolution">resolution</a></code></li>
<li><code><a title="spdl.Stream.url" href="#spdl.Stream.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spdl.Video" href="#spdl.Video">Video</a></code></h4>
<ul class="two-column">
<li><code><a title="spdl.Video.RTMP_STREAMS" href="#spdl.Video.RTMP_STREAMS">RTMP_STREAMS</a></code></li>
<li><code><a title="spdl.Video.captions" href="#spdl.Video.captions">captions</a></code></li>
<li><code><a title="spdl.Video.duration" href="#spdl.Video.duration">duration</a></code></li>
<li><code><a title="spdl.Video.get_play_data" href="#spdl.Video.get_play_data">get_play_data</a></code></li>
<li><code><a title="spdl.Video.get_stream" href="#spdl.Video.get_stream">get_stream</a></code></li>
<li><code><a title="spdl.Video.get_streams" href="#spdl.Video.get_streams">get_streams</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
